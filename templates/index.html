<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>World Mosaic</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>
<body>

<header>
  <h1>üåç World Mosaic</h1>
  <div class="controls">
    <a class="btn" href="{{ url_for('submit') }}">‚ûï Add Note</a>
    <span>Total Notes: {{ notes|length }}</span>
    <select id="langSelect">
      <option value="">Original</option>
      <option value="en">English</option>
      <option value="es">Spanish</option>
      <option value="fr">French</option>
      <option value="de">German</option>
      <option value="ja">Japanese</option>
    </select>
  </div>
</header>

<div id="canvas-container">
  <div id="canvas">
    {% for note in notes %}
      <div class="tile" data-index="{{ loop.index0 }}">
        <div class="note-text">{{ note.text }}</div>
      </div>
    {% endfor %}
  </div>
</div>

<footer>
  <small>Use mouse wheel to zoom, drag to pan. Select a language to translate all notes.</small>
</footer>

<script>
const canvas = document.getElementById('canvas');
const container = document.getElementById('canvas-container');
let scale = 1, posX = 0, posY = 0;
let isPanning = false, startX, startY;
let lastDist = null;

function updateTransform(){
  canvas.style.transform = `translate(calc(-50% + ${posX}px), calc(-50% + ${posY}px)) scale(${scale})`;
}

// Mouse zoom
container.addEventListener('wheel', e => {
  e.preventDefault();
  scale += e.deltaY * -0.0015;
  scale = Math.min(Math.max(0.2, scale), 3);
  updateTransform();
});

// Mouse pan
container.addEventListener('mousedown', e => {
  isPanning = true;
  startX = e.clientX - posX;
  startY = e.clientY - posY;
});
window.addEventListener('mouseup', () => isPanning = false);
window.addEventListener('mousemove', e => {
  if (!isPanning) return;
  posX = e.clientX - startX;
  posY = e.clientY - startY;
  updateTransform();
});

// Touch support
container.addEventListener('touchstart', e => {
  if(e.touches.length === 1){
    isPanning = true;
    startX = e.touches[0].clientX - posX;
    startY = e.touches[0].clientY - posY;
  } else if(e.touches.length === 2){
    lastDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
  }
}, { passive: false });

container.addEventListener('touchmove', e => {
  e.preventDefault();
  if(e.touches.length === 1 && isPanning){
    posX = e.touches[0].clientX - startX;
    posY = e.touches[0].clientY - startY;
    updateTransform();
  } else if(e.touches.length === 2){
    let dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    if(lastDist){
      let delta = dist - lastDist;
      scale *= 1 + delta / 300;
      scale = Math.min(Math.max(0.2, scale), 3);
      updateTransform();
    }
    lastDist = dist;
  }
}, { passive: false });

container.addEventListener('touchend', e => {
  if(e.touches.length < 2) lastDist = null;
  if(e.touches.length === 0) isPanning = false;
});

// Center-out square grid
function positionTilesSquareGrid() {
  const tiles = document.querySelectorAll('.tile');
  const tileWidth = 150;
  const tileHeight = 90;
  const spacing = 20;

  const totalNotes = tiles.length;
  const gridSize = Math.ceil(Math.sqrt(totalNotes));
  const centerOffset = (gridSize - 1) / 2;

  tiles.forEach((tile, idx) => {
    const row = Math.floor(idx / gridSize);
    const col = idx % gridSize;

    const x = (col - centerOffset) * (tileWidth + spacing);
    const y = (row - centerOffset) * (tileHeight + spacing);

    tile.style.position = 'absolute';
    tile.style.left = `${x}px`;
    tile.style.top = `${y}px`;
    tile.dataset.x = x;
    tile.dataset.y = y;

    if(!tile.dataset.original){
      tile.dataset.original = tile.querySelector('.note-text').textContent;
    }
  });
}
positionTilesSquareGrid();

// Focus on newest note
function focusOnLatestNote() {
  const tiles = document.querySelectorAll('.tile');
  if(!tiles.length) return;
  const last = tiles[tiles.length-1];
  const targetX = -parseFloat(last.dataset.x);
  const targetY = -parseFloat(last.dataset.y);

  const steps = 15;
  let step = 0;
  const startX = posX, startY = posY;
  const anim = setInterval(() => {
    step++;
    posX = startX + (targetX - startX) * (step / steps);
    posY = startY + (targetY - startY) * (step / steps);
    updateTransform();
    if(step >= steps) clearInterval(anim);
  }, 20);

  scale = 1.2;
  updateTransform();
}

focusOnLatestNote();

// Translation
document.getElementById('langSelect').addEventListener('change', async () => {
    const lang = document.getElementById('langSelect').value;
    const tiles = document.querySelectorAll('.tile');
    if(!lang){
        tiles.forEach(tile => tile.querySelector('.note-text').textContent = tile.dataset.original);
        return;
    }
    const indices = Array.from(tiles).map(t => t.dataset.index);
    try{
        const resp = await fetch("/translate", {
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body: JSON.stringify({indices, lang})
        });
        const data = await resp.json();
        tiles.forEach(tile => {
            const idx = tile.dataset.index;
            if(data[idx]){
                tile.querySelector('.note-text').textContent = data[idx];
                tile.dataset[lang] = data[idx];
            }
        });
    }catch(err){
        console.error("Translation failed", err);
        alert("Translation failed. Check console.");
    }
});
</script>

</body>
</html>
